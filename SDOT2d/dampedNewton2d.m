function [w,tol_1] = dampedNewton2d(bx,Z,a_target,w_0,tol,per_x,per_y)

%Function for computing the weights w of a Laguerre diagram in 2D with N x 2 
%seed matrix Z so that the Laguerre cells have given areas a_target up to tol 
%percentage error. 

%Input
%{
       bx             - 1 x 4 row vector specifying [xmin,ymin,xmax,ymax] of the rectangular source domain
       Z(:,1), Z(:,2) - N x 1 column vectors containing the x- and y-coordinates 
                        of the seeds, respectively.
       a_target       - N x 1 column vector containing desired areas of cells
       w_0            - N x 1 column vector containing initial guess for weights
       tol            - tolerance for the convex optimization algorithm
       per_x        - periodic flag (a boolean true/false to indicate periodicity in x-direction)
       per_y        - periodic flag (a boolean true/false to indicate periodicity in y-direction)
%}
%Output
%{
       w        - N x 1 column vector of weights such that cells in Laguerre
                  tessellation of bx generated by (Z,w) have areas a_target up 
                  to tol percentage error.
       tol_1    - areas percentage error
%}
% Example
%{

% 1000 seeds randomly distributed in a unit square with equal mass
% Expected run time: approximately 0.2 seconds

N = 1000;
Z = rand(N,2);
bx = [0,0,1,1];
a_target = (bx(3)-bx(1))*(bx(4)-bx(2))*ones(N,1)/N;
w_0 = zeros(N,1);
tol = 1;
per_x = false;
per_y = false;
tic
[w,tol_1] = dampedNewton2d(bx,Z,a_target,w_0,tol,per_x,per_y);
toc
%}

%% Set up
N   = length(w_0);              % number of seeds
tol = tol*1e-2*min(a_target);   % convert relative tolerance from % relative error to absolute tolerance
w_0 = w_0-w_0(N);               % Adjust the weights so that the final weight is zero (adding a constant to all weights does not change the cells)
a_0 = mexPDall_2d(bx,Z,w_0,per_x,per_y);     % a_0 = areas of initial cells


tol_1 = max(abs(a_0-a_target));        

if tol_1<=tol % If the initial guess is good enough, set the output
    w     = w_0;
    tol_1 = tol_1*100/min(a_target);
    return
end

%% Define epsilon parameter (Merigot and Thibet 2020, algorithm 4, p55)
epsilon1 = min(a_target);
epsilon2 = min(a_0);
epsilon  = 0.5*min([epsilon1,epsilon2]);

%% Check that all areas are positive
if epsilon <=0
    error("Zero area cell encountered");
end

%% While loop
while(tol_1 > tol)
    
    [~,Dg,H,a_0] = kantorovich2d(bx,Z,a_target,w_0,per_x,per_y);  % calculate the gradient and Hessian of the Kantorovich functional
    
    % Step 1
    H_mod = H(1:N-1,1:N-1);      % truncate the Hessian matrix 
    v_k   = H_mod\(-Dg(1:N-1));  % solve linear system for v_k
    v_k   = [v_k;0];             % augment v_k
   
    % Step 2
    backtrack=true;
    l = 0;
    
    while(backtrack)
        w_l      = w_0 + (2^(-l))*v_k;  % new weight value to test
        a_l      = mexPDall_2d(bx,Z,w_l,per_x,per_y);  % compute minimum area of cells generated by (Z,w_l)
        min_area = min(a_l);
        
        if (min_area > epsilon) % if min_area <= eps then backtrack
            
            % compute the other criteria we need to check
            dist_new  = norm(a_l - a_target);
            dist_old  = norm(a_0 - a_target);
            ratio     = dist_new/dist_old;
            threshold = 1 - 2^(-(l+1));
            
            % if all the criteria are met
            if (ratio < threshold)
                % update and terminate
                w_0 = w_l;
                backtrack = false;
                % otherwise update l
            else
                l = l + 1;
            end
            % again otherwise update l
        else
            l = l + 1;
        end 
    end
    
    % if we exited the while loop tol is the dist_new defined earlier
    tol_1 =  max(abs(a_l-a_target));
end

% Set the output
w     = w_0;
tol_1 = tol_1*100/min(a_target);

end
